# API настроек уведомлений

Этот документ описывает, как клиент (мобильное приложение) работает с настройками уведомлений и какие эндпоинты ожидает от Laravel API.

## Общие принципы

- Настройки уведомлений хранятся на стороне сервера и привязаны к текущему пользователю (через Sanctum токен).
- Клиент использует **offline-first** подход:
  - последние выбранные пользователем значения кешируются локально;
  - изменения применяются сначала локально (optimistic update) и ставятся в очередь синхронизации;
  - при наличии сети очередь отправляет изменения на сервер через `/notification-settings`.
- Все операции выполняются от имени авторизованного пользователя.

## Модель настроек уведомлений

### Поля настроек (клиент)

```ts
export type NotificationSettings = {
  pushEnabled: boolean;       // Включены ли push-уведомления вообще
  friendRequests: boolean;    // Запросы в друзья
  wishFulfilled: boolean;     // Исполнение желаний пользователя
  reminders: boolean;         // Напоминания о событиях (дни рождения, праздники)
  newWishes: boolean;         // Новые желания друзей
};
```

### Ответ сервера

Клиент ожидает объект настроек в обёртке:

```json
{
  "data": {
    "id": "uuid",
    "user_id": "uuid",
    "pushEnabled": true,
    "friendRequests": true,
    "wishFulfilled": true,
    "reminders": true,
    "newWishes": false,
    "created_at": "2025-01-01T12:00:00Z",
    "updated_at": "2025-01-01T12:00:00Z"
  }
}
```

Имена полей могут быть приведены к `snake_case` на сервере, главное — согласованное преобразование на стороне API-слоя. Клиент готов адаптироваться к финальному формату.

## Эндпоинты

### 1. Получить текущие настройки уведомлений

`GET /notification-settings`

**Назначение:**

- Клиент вызывает этот эндпоинт при первой загрузке настроек (если локального кеша ещё нет).
- В дальнейшем экран уведомлений в первую очередь читает из локального хранилища, а сервер используется для инициализации/актуализации.

**Ответ 200:** см. структуру выше.

### 2. Обновить настройки уведомлений

`PUT /notification-settings`

**Назначение:**

- Применить изменения, сделанные пользователем на экране уведомлений.
- Клиент может отправлять либо полный объект настроек, либо частичный (PATCH‑подобное поведение) — рекомендуется поддержать оба варианта, но в текущей реализации клиент всегда шлёт полный набор булевых полей.

**Пример запроса:**

```json
{
  "pushEnabled": true,
  "friendRequests": true,
  "wishFulfilled": false,
  "reminders": true,
  "newWishes": true
}
```

**Ответ 200:**

Тот же объект, что в `GET /notification-settings` (актуальное состояние после сохранения).

```json
{
  "data": {
    "id": "uuid",
    "user_id": "uuid",
    "pushEnabled": true,
    "friendRequests": true,
    "wishFulfilled": false,
    "reminders": true,
    "newWishes": true,
    "created_at": "2025-01-01T12:00:00Z",
    "updated_at": "2025-01-01T12:05:00Z"
  }
}
```

## Поведение клиента (offline-first)

1. При открытии экрана уведомлений клиент:
   - пробует прочитать настройки из локального хранилища;
   - если настроек нет, делает `GET /notification-settings`;
   - если сервер недоступен, инициализирует настройки значениями по умолчанию и помечает их как требующие синхронизации.

2. При переключении любого тумблера:
   - новые значения сразу сохраняются локально (пользователь видит мгновенный результат);
   - в очередь синхронизации добавляется операция `update` с текущим набором настроек;
   - фоновый процесс синхронизации пытается отправить изменения через `PUT /notification-settings`.

3. При успешной синхронизации:
   - клиент обновляет локальный кеш ответом сервера и помечает настройки как `synced`.

4. При ошибках сети:
   - операции остаются в очереди и будут повторно отправлены при следующей попытке синхронизации.

## Связь с FCM

- Поле `pushEnabled` используется клиентом для решения, показывать ли пользователю запрос на системное разрешение push‑уведомлений и/или регистрировать FCM‑токен на сервере.
- Детальная логика работы с FCM токеном описывается отдельно (см. соответствующий документ по FCM), здесь важно, что сервер может хранить булев флаг, хочет ли пользователь получать push‑уведомления в принципе.
